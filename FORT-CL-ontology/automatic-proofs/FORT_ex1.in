logic CommonLogic 

ontology  assumption = 


(cl-comment ' ---------------------------------------------------- Mereology ')

(cl-comment 'Pa1')
(forall (x)
	(part x x)
)

(cl-comment 'Pa2')
(forall (x y)
        (if     (and	(part x y)
			(part y x))
		(= x y))
)

(cl-comment 'Pa3')
(forall (x y z)
        (if     (and    (part x y)
                        (part y z))
                (part x z))
)

(cl-comment 'Pd3')
(forall (x y)
(iff    (overlaps x y)
        (exists (z)
                (and    (part z x)
                        (part z y))))
)

(cl-comment 'Pd4')
(forall (x y)
(iff    (underlaps x y)
        (exists (z)
                (and    (part x z)
                        (part y z))))
)

(cl-comment 'Pa6')
(cl-comment 'Sum')
(forall (x y)
	(if	(underlaps x y)
		(exists (z)
			(forall (v)
				(iff	(overlaps v z)
					(or	(overlaps v x)
						(overlaps v y))))))
)

(cl-comment 'Pa7')
(cl-comment 'Product')
(forall (x y)
	(if	(overlaps x y)
		(exists (z)
			(forall (v)
				(iff	(part v z)
					(and	(part v x)
						(part v y))))))
)

(cl-comment 'Pa5; which also implies weak supplementation axiom Pa4')
(cl-comment 'Strong Supplementation Principle')
(forall (x y)
        (if     (not (part x y))
                (exists (z)
                        (and    (part z x)
                                (not (overlaps z y)))))
)

(cl-comment 'Pd1')
(forall (x y)
(iff	(ppart x y)
	(and	(part x y)
		(not (part y x))))
)

(cl-comment 'Pd2 : equal can be represented using the symbol = thus no need to add definition')


(cl-comment 'Pd5')
(forall (x y)
(iff	(overcross x y) 
		(and (overlaps x y) (not (part x y)) )
)
)

(cl-comment 'Pd6')
(forall (x y)
(iff	(undercross x y) 
		(and (underlaps x y) (not (part y x)) )
)
)

(cl-comment 'Pd7')
(forall (x y)
(iff	(partialoverlap x y) 
		(and (overcross x y) (overcross y x) )
)
)

(cl-comment 'Pd8')
(forall (x y)
(iff	(partialunderlap x y) 
		(and (undercross x y) (undercross y x) ))
)

(cl-comment 'Pd9')
(cl-comment 'Proper Overlap')
(forall (x y)
	(iff	(PO x y)
		(and	(overlaps x y)
			(not (part x y))
			(not (part y x))))
)

(cl-comment 'Pa9')
(forall (x y z)
	(iff	(sum x y z)
		(forall (w)
			(iff	(overlaps w z)
				(or	(overlaps w x)
					(overlaps w y)))))
)

(cl-comment 'Pa10')
(forall (x y z)
	(iff	(prod x y z)
		(forall (w)
			(iff	(part w z)
				(or	(part w x)
					(part w y)))))
)

(cl-comment '+++++++++++++++++++')
(forall (x y)
(iff    (disjoint x y)
        (not (overlaps x y)))
)

(cl-comment '+++++++++++++++++++')
(forall (x)
(iff	(atomic_part x)
	(forall (y)
		(if	(part y x)
			(= y x))))
)

(cl-comment '+++++++++++++++++++')
(forall (x z)
	(iff	(comp x z)
		(forall (y)
			(iff	(part y z)
				(not (overlaps y x)))))
)




(cl-comment ' ---------------------------------------------------- Mereotopology ')

(cl-comment 'Reflexivity')
(cl-comment 'Ca1')
(forall (x) 
	(C x x))

(cl-comment 'Symmetry')
(cl-comment 'Ca2')
(forall (x y)
	(if	(C x y)
		(C y x))
)

(cl-comment 'bridging axiom')
(cl-comment 'Ca3')
(forall (x y)
	(if	(part x y)
		(forall (z)
			(if	(C x z)
				(C z y))))
)

(cl-comment 'Disconnected')
(cl-comment 'Cd10')
(forall (x y)
	(iff	(DC x y)
		(not (C x y)))
)

(cl-comment 'External Connection')
(cl-comment 'Cd1')
(forall (x y)
	(iff	(EC x y)
		(and	(C x y)
			(not (overlaps x y))))
)

(cl-comment 'Internal part')
(cl-comment 'Cd3')
(forall (x y)
	(iff	(IP x y)
		(and	(part x y)
			(forall (z)
				(if	(C z x)
					(overlaps z y)))))
)


(cl-comment 'Tangential part')
(cl-comment 'Cd2')
(forall (x y)
	(iff	(TP x y)
		(and	(part x y)
			(not (IP x y))))
)

(cl-comment 'Internal Overlap')
(cl-comment 'Cd6')
(forall (x y)
	(iff	(IO x y)
		(exists (z)
			(and	(IP z x)
				(IP z y))))
)


(cl-comment 'Tangential Overlap')
(cl-comment 'Cd7')
(forall (x y)
	(iff	(TO x y)
		(and	(overlaps x y)
			(not (IO x y))))
)


(cl-comment 'Internal Underlap')
(cl-comment 'Cd8')
(forall (x y)
	(iff	(IU x y)
		(exists (z)
			(and	(IP x z)
				(IP y z))))
)

(cl-comment 'Tangnetial Underlap')
(cl-comment 'Cd9')
(forall (x y)
	(iff	(TU x y)
		(and	(underlaps x y)
			(not (IU x y))))
)

(cl-comment 'Internal proper part')
(cl-comment 'Cd4')
(forall (x y)
	(iff	(IPP x y)
		(and	(IP x y)
			(not (IP y x))))
)

(cl-comment 'Tangential Proper Part')
(cl-comment 'Cd5')
(forall (x y)
	(iff	(TPP x y)
		(and	(part x y)
			(not (= x y))
			(exists (z)
				(and	(EC z x)
					(EC z y)))))
)

(cl-comment 'Non-Tangential Proper Part')
(cl-comment 'Cd11')
(forall (x y)
	(iff	(NTPP x y)
		(and	(part x y)
			(not (= x y))
			(not (exists (z)
				(and	(EC z x)
					(EC z y)) ) ) ) )
)


(cl-comment '+++++++++++++++++++')
(cl-comment 'Enclosure')
(forall (x y)
	(iff	(E x y)
		(forall (z)
			(if	(C z x)
				(C z y))))
)

(cl-comment '+++++++++++++++++++')
(forall (x y)
	(iff	(superposition x y)
		(exists (z)
			(and	(E z x)
				(E z y))))
)

(cl-comment '+++++++++++++++++++')
(forall (x y)
	(iff	(proper_superposition x y)
		(and	(superposition x y)
			(not (E x y))
			(not (E y x))))
)

(cl-comment '+++++++++++++++++++')
(forall (x y)
	(iff	(boundary_connected x y)
		(and	(C x y)
			(not (superposition x y))))
)

(cl-comment '+++++++++++++++++++')
(forall (x y)
	(iff	(internal_enclosure x y)
		(forall (z)
			(if	(C z x)
				(S z y))))
)

(cl-comment '+++++++++++++++++++')
(forall (x y)
	(iff	(proper_internal_enclosure x y)
		(and	(internal_enclosure x y)
			(E x y)
			(not (E y x))))
)

(cl-comment '+++++++++++++++++++')
(forall (x y)
	(iff	(tangential_enclosure x y)
		(and	(E x y)
			(not (internal_enclosure x y))))
)

(cl-comment '+++++++++++++++++++')
(forall (x y)
	(iff	(proper_tangential_enclosure x y)
		(and	(tangential_enclosure x y)
			(proper_enclosure y x)))
)

(cl-comment '+++++++++++++++++++')
(forall (x)
	(iff	(SC x)
		(forall (y z)
			(if	(forall (w)
					(iff	(overlaps w x)
						(or	(overlaps w y)
							(overlaps w z))))
				(C y z))))
)




(cl-comment ' ---------------------------------------------------- Location Varzi')

(cl-comment 'Identifier: FORT_La2')
(forall (x y z)
	(if	(and	(L x y)
			(L x z))
		(= y z))
)

(cl-comment 'Identifier: FORT_La1')
(forall (x y)
	(if	(L x y)
		(L y y))
)

(cl-comment 'Identifier: FORT_Ld1')
(forall (x y)
	(iff	(PL x y)
		(exists (z)
			(and	(part z x)
				(L z y))))
)

(cl-comment 'equivalent to (EL x y)')

(cl-comment 'Identifier: FORT_Ld2')
(forall (x y)
	(iff	(TPL x y)
		(exists (z)
			(and	(TP z x)
				(L z y))))
)


(cl-comment 'Identifier: FORT_Ld3')
(forall (x y)
	(iff	(IPL x y)
		(exists (z)
			(and	(IP z x)
				(L z y))))
)
				
(cl-comment 'Identifier: FORT_Ld4')
(forall (x y)
	(iff	(WL x y)
		(exists (z)
			(and	(part z y)
				(L x z))))
)

(cl-comment 'Identifier: FORT_Ld5')		
(forall (x y)
	(iff	(TWL x y)
			(exists (z)
				(and (TP z y) (L x z) )
			)
	)
)

(cl-comment 'Identifier: FORT_Ld6')
(forall (x y)
	(iff	(IWL x y)
			(exists (z)
				(and (IP z y) (L x z) )
			)
	)
)

(cl-comment 'Identifier: FORT_La3')
(forall (x y)
	(if		(L x y)
			(and (PL x y) (WL x y) )
	)
)

(cl-comment '+++++++++++++++++++')
(forall (x y)
	(iff	(GL x y)
		(exists (z w)
			(and	(part z x)
				(part w y)
				(L z w))))
)

(cl-comment '+++++++++++++++++++')
(forall (x y)
	(iff	(UL x y)
		(exists (z)
			(and	(part y z)
				(L x z))))
)

(cl-comment '+++++++++++++++++++')
(forall (x y)
	(iff	(proper_location x y)
		(and	(L x y)
			(not (L y x))))
)

(cl-comment 'Identifier: FORT_La4')
(forall (x y z w)
	(if	(and	(part x y)
			(L x z)
			(L y w))
		(part z w))
)

(cl-comment 'Identifier: FORT_La5')
(forall (x y z w)
	(if	(and	(C x y)
			(L x z)
			(L y w))
		(C z w))
)


(cl-comment 'Identifier: FORT_Lt4')
(forall (x y z)
	(if	(and (P x y) (L y z))
		(WL x z))
)

(cl-comment 'Identifier: FORT_Lt5')
(forall (x y z)
	(if	(and (TP x y) (L y z))
		(TWL x z))
)


(cl-comment 'Identifier: FORT_Lt6')
(forall (x y z)
	(if	(and (IP x y) (L y z))
		(IWL x z))
)

(cl-comment 'Identifier: FORT_Lt7')
(forall (x y z)
	(if	(and	(part x y)
			(L z y))
		(PL z x))
)

(cl-comment 'Identifier: FORT_Lt9')
(forall (x y z)
	(if	(and	(TP x y)
			(L z y))
		(TPL z x))
)


(cl-comment 'Identifier: FORT_Lt8')
(forall (x y z)
	(if	(and	(IP x y)
			(L z y))
		(IPL z x))
)

(cl-comment 'Identifier: FORT_Lt10')
(forall (x y z)
	(if	(and (PL x y) (P z y))
		(PL x z))
)


(cl-comment 'Identifier: FORT_Lt11')
(forall (x y z)
	(if	(and (IPL x y) (P z y))
		(IPL x z))
)


(cl-comment 'Identifier: FORT_Lt12')
(forall (x y z)
	(if	(and (TPL x y) (P z y))
		(TPL x z))
)

(cl-comment 'Identifier: FORT_Lt13')
(forall (x y z)
	(if	(and (WL x y) (P z x))
		(WL z y))
)


(cl-comment 'Identifier: FORT_Lt14')
(forall (x y z)
	(if	(and (IWL x y) (IP z x))
		(IWL z y))
)


(cl-comment 'Identifier: FORT_Lt15')
(forall (x y z)
	(if	(and (TPL x y) (P z y))
		(TPL x z))
)





(cl-comment ' ---------------------------------------------------- FORT ')

(forall (x t)
	(if	(existing x t)
		(not (existing t x) )
	)
)

(forall (x y)
	(iff	(SED x y)
			(and	( forall (t)
						(if (existing x t)
							(existing y t)
						)
					)
					( not (= x y) )
					( exists (t)
						(existing x t)
					)
			)
	)
)


(forall (x y z)
	(if 	(and (SED x y) (SED y z) )
			(SED x z)
	)
)


(forall (PSI PHI x y)
	(iff	(GED (PSI x) (PHI y))
			(and	(forall (x t)
						(if (and (PSI x) (existing x t) )
						   (exists (y)
								(and (PHI y) (existing y t) )
						   )
						)
					)
					(exists (x t)
						(and (PSI x) (existing x t))
					)
					(not (exists (z) (and (PSI z) (PHI z) ) )
					)
			)
	)
)

(forall (PSI PHI RHO x y z)
	(if 	(and (GED (PSI x) (PHI y) ) (GED (PHI y) (RHO z) ) (not (exists (m) (and (PSI m) (RHO m) ) ) ) )
			(GED (PSI x) (RHO z) )
	)
)





(forall (x y)
	(iff	(componentOf x y)
			(and (part x y)  (exists (PSI PHI) (and (PSI y) (PHI x) (GED (PSI y) (PHI x)) ) )
 			)
	)
)

(forall (x y)
	(if	(componentOf x y)
			(ppart x y)
	)
)

(forall (x y z)
        (if     (and    (componentOf x y)
                        (componentOf y z))
                (componentOf x z)
		)
)

(forall (x)
	(not (componentOf x x))
)

(forall (x y)
        (if (componentOf x y)
			(not (componentOf y x))
		)
)

(forall (x y)
        (if (componentOf x y)
			( exists (z) (and (part z y) (not(overlaps z x)) )
			)
		)
)




(forall (x y)
	(iff	(elementOf x y)
			(and (part x y) (SED y x)
 			)
	)
)

(forall (x y)
	(if	(elementOf x y)
			(ppart x y)
	)
)

(forall (x y z)
        (if     (and    (elementOf x y)
                        (elementOf y z))
                (elementOf x z)
		)
)

(forall (x)
	(not (elementOf x x))
)

(forall (x y)
        (if (elementOf x y)
			(not (elementOf y x))
		)
)

(forall (x y)
        (if (elementOf x y)
			( exists (z) (and (part z y) (not(overlaps z x)) )
			)
		)
)



(forall (x)
	(EL x x)
)

(forall (x y z)
        (if     (and    (EL x y)
                        (EL y z))
                (EL x z)
		)
)

(forall (x y)
	(if	(part x y)
			(EL x y)
	)
)

(forall (x y z)
	(if (and (part x y) (EL y z) )
		(EL x y)
	)
)

(forall (x y z)
	(if (and (EL x y) (part y z) )
		(EL x y)
	)
)

(forall (x y z)
	(if (and (EL x y) (L y z) )
		(WL x z)
	)
)

(forall (x y z w)
	(if (and (EL x y) (L x z) (L y w) )
		(part z w)
	)
)






(forall (z)
	(exists (R)
	(iff (U (R z z))
		 (and (forall (r) (if (R r r) (part r z) ) )
			  (forall (m) (if (overlaps m z) (exists (r) (and (R r r) (overlaps m r) ) ) ))
			  (forall (a b) (if (and (R a a) (R b b) (part a z) (part b z) ) (R a b) ) )
			  (forall (a b) (if (R a b) (and (R a a) (R b b))  ))
			  (forall (a b) (if (R a b) (R b a)  ))
		 )
	)
	)
)

(forall (x)
	(not (memberOf x x) )
)

(forall (x y)
	(if (memberOf x y)
		(not (memberOf y x) )
	)
)

(forall (x y)
	(if (memberOf y x)
		(exists (t m n)
			(and (existing x t)
				 (not(= m n))
				 (memberOf m x)
				 (memberOf n x)
			)
		)
	)
)

(forall (x p y)
	(if (and (memberOf y x) (ppart p x) )
		(exists (o) 
			(and (memberOf o x) (overlaps o p) )
		)
	)
)

(forall (x y)
	(if	(memberOf x y)
		(and (ppart x y)
			 (forall (m) 
				 (if (memberOf m y) 
					 (or (= x d) (not(overlaps m x)) )
				 )
			 )
		)
	)
)

(forall (x y)
	(if (memberOf y x)
		(forall (w) 
			(iff (overlaps w x) 
				 (exists (m) 
					(and (memberOf m x) (overlaps w m) )
				 ) 
			)
		)
	)
)

(forall (x y)
	(if (memberOf y x)
		(exists (R)
			(and (U (R x x))
				 (forall (t) (if (existing x t) (U (R x x)) ) ) 
			)
		)	
	)
)

(forall (x y w z)
	(if 
		(and (memberOf x y) (memberOf w z) (U (R y y)) (U (F z z)) (= R F) )
		(= y z )
	)
)








(forall (x)
	(not (constitutes x x) 	)
)

(forall (x y)
	(if (constitutes x y)
	    (not (constitutes y x ) )
	)
)

(forall (x y z)
	(if (and (constitutes x y) (constitutes y z) )
	    (constitutes x z)
	)
)

(forall (x y)
	(if (constitutes x y)
	    (exists (t) (and (existing x t) (existing y t) ) )
	)
)

(forall (x y)
	(if (and (constitutes x y) (part z y) )
	    (exists (w) (and (part w x) (constitutes w z) ) )
	)
)

(forall (x y)
	(iff (SCD x y) 
		 (and (exists (t) (existing x t) )
			  (forall (t) (if (existing x t) (constitutes y x) ) )
		 )
	)
)

(forall (PSI PHI x y)
	(iff (GCD (PSI x) (PHI y)) 
		 (and (not (exists (z) (and (PSI z) (PHI z) ) ) )
			  (forall (x) (if (PSI x) (exists (t) (existing x t) ) ) )
			  (forall (x t) (if (and (PSI x) (existing x t) ) 
								(exists (y) (and (PHI y) (constitutes y x) ) )
							)
			   )
		 )
	)
)

(forall (x y)
	(if	(SCD x y) (SED x y) )
)


(forall (PSI PHI x y)
	(if	(GCD (PSI x) (PHI y)) (GED (PSI x) (PHI y)) )
)


(forall (x y z)
	(if (and (SCD x y) (SCD y z) ) 
		(SCD x z)
	)
)

(forall (PSI PHI RHO x y z)
	(if	(and (GCD (PSI x) (PHI y))
			 (GCD (PHI y) (RHO z))
			 (not (exists (z) (and (PSI z) (RHO z) ) ) )
		)
		(GCD (PSI x) (RHO z) )
	)
)

(forall (x y PSI PHI)
	(if	 (constitutes x y) 
		 (exists (PSI PHI) (and (PSI y) (PHI x)(GCD (PSI y) (PHI x)) ) )
	)
)

(forall (x y)
	(if  (constitutes x y)
		 (forall (z) (if (part z x) (elementOf z x) ) )
	)
)

(indiscourse a) 
(indiscourse now)

end 



ontology conjecture = assumption then %implies 

(if (existing a now) (not (existing now a )))
end 